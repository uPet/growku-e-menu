/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import CryptoJS from "crypto-js";
import { Store, get, set } from "idb-keyval";
import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(({ request, url }: { request: Request; url: URL }) => {
  console.log('fileExtensionRegexp url :>> ', url);
  if (
    request.mode !== "navigate" ||
    url.pathname.startsWith("/_") ||
    url.pathname.match(fileExtensionRegexp)
  ) {
    return false;
  }
  return true;
}, createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html"));

// Cache all images on the site
registerRoute(
  ({ request }: { request: Request }) => request.destination === "image",
  new StaleWhileRevalidate({
    cacheName: "all-images",
    plugins: [new ExpirationPlugin({ maxEntries: 500 })], // Cache up to 500 images, assume we have max 100 products and each one has 5 images.
  })
);

// Cache all videos on the site
registerRoute(
  ({ request }: { request: Request }) => request.destination === "video",
  new StaleWhileRevalidate({
    cacheName: "videos",
    plugins: [new ExpirationPlugin({ maxEntries: 100 })], // Probably we need to adjust this number in the future.
  })
);

// Cache Google Sheets API requests
registerRoute(
  ({ url }) => {
    console.log("google url :>> ", url);
    return (
      (url.origin === "https://content.googleapis.com" &&
        url.pathname.startsWith("/v4/rest")) ||
      (url.origin === "https://content-sheets.googleapis.com" &&
        url.pathname.startsWith("/v4/spreadsheets"))
    );
  },
  new StaleWhileRevalidate({
    cacheName: "google-sheets-cache",
    plugins: [
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 24 * 60 * 60 }),
    ], // Cache up to 50 requests for 24 hours
  })
);

// Cache Google Sheets API requests
registerRoute(
  ({ url }) =>
    (url.origin === "https://content.googleapis.com" &&
      url.pathname.startsWith("/v4/rest")) ||
    (url.origin === "https://content-sheets.googleapis.com" &&
      url.pathname.startsWith("/v4/spreadsheets")),
  new StaleWhileRevalidate({
    cacheName: "google-sheets-cache",
    plugins: [
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 24 * 60 * 60 }),
    ], // Cache up to 50 requests for 24 hours
  })
);

// Allow the web app to trigger skipWaiting via registration.waiting.postMessage({ type: 'SKIP_WAITING' })
self.addEventListener("message", (event: ExtendableMessageEvent) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.

/*
 *
 * Start of custom service worker logic to cache the graphql POST requests.
 * Why do we need this?
 * Ans: Browser cache storage doesn't has an ability to persist POST requests as a keys. See https://w3c.github.io/ServiceWorker/#cache-put (point 4).
 * Here is the reference for the solution (we used the second solution): https://medium.com/@jono/cache-graphql-post-requests-with-service-worker-100a822a388a
 */

// Handle POST fetch events
self.addEventListener("fetch", (event: FetchEvent) => {
  if (event.request.method === "POST") {
    event.respondWith(staleWhileRevalidate(event));
  }
});

// IndexedDB setup
const store = new Store("GraphQL-Cache", "PostResponses");

async function getCache(request: Request): Promise<Response | null> {
  try {
    const body = await request.clone().json();
    const id = CryptoJS.MD5(body.query).toString();
    const data = await get<{ response: Response; timestamp: number } | null>(
      id,
      store
    );
    if (!data) return null;

    const cacheControl = request.headers.get("Cache-Control");
    const maxAge = cacheControl ? parseInt(cacheControl.split("=")[1]) : 3600;
    const isCachedExpired = Date.now() - data.timestamp > maxAge * 1000;
    if (isCachedExpired) {
      return null;
    }

    return new Response(JSON.stringify(data.response.body), data.response);
  } catch (err) {
    console.error(err);
    return null;
  }
}

async function serializeResponse(response: Response): Promise<{
  headers: HeadersInit;
  status: number;
  statusText: string;
  body: any;
}> {
  const serializedHeaders: HeadersInit = {};
  const headersArray = Array.from(response.headers.entries());
  for (const entry of headersArray) {
    serializedHeaders[entry[0]] = entry[1];
  }
  const serialized = {
    headers: serializedHeaders,
    status: response.status,
    statusText: response.statusText,
    body: await response.json(),
  };
  return serialized;
}

async function setCache(request: Request, response: Response): Promise<void> {
  try {
    const body = await request.clone().json();
    const id = CryptoJS.MD5(body.query).toString();
    const entry = {
      query: body.query,
      response: await serializeResponse(response),
      timestamp: Date.now(),
    };
    await set(id, entry, store);
  } catch (err) {
    console.error(err);
  }
}

async function staleWhileRevalidate(event: FetchEvent): Promise<Response> {
  let cachedResponse: Response | null = await getCache(event.request.clone());

  try {
    // Serve the cached response immediately if available
    if (cachedResponse) {
      // Start a fetch request in the background to get a fresh response
      fetch(event.request.clone())
        .then(async (fetchResponse) => {
          const responseClone = fetchResponse.clone();
          await setCache(event.request.clone(), responseClone);
        })
        .catch((error) => {
          console.error("Fetch error:", error);
        });

      return cachedResponse;
    }

    // If no cached response is found, fetch from the network
    const fetchResponse = await fetch(event.request.clone());

    const responseClone = fetchResponse.clone();
    await setCache(event.request.clone(), responseClone);

    return fetchResponse;
  } catch (error) {
    console.error("staleWhileRevalidate error:", error);
    // If an error occurs during the process, return the cached response if available
    // Otherwise, return a generic service unavailable response
    return (
      cachedResponse ||
      new Response(null, { status: 503, statusText: "Service Unavailable" })
    );
  }
}

/*
 * End of custom service worker logic to cache the graphql POST requests.
 */
