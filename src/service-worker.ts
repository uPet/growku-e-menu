/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import CryptoJS from "crypto-js";
import { Store, get, set } from "idb-keyval";
import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(({ request, url }: { request: Request; url: URL }) => {
  if (
    request.mode !== "navigate" ||
    url.pathname.startsWith("/_") ||
    url.pathname.match(fileExtensionRegexp)
  ) {
    return false;
  }
  return true;
}, createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html"));

// Cache all images on the site
registerRoute(
  ({ request }: { request: Request }) => request.destination === "image",
  new StaleWhileRevalidate({
    cacheName: "all-images",
    plugins: [new ExpirationPlugin({ maxEntries: 500 })], // Cache up to 500 images, assume we have max 100 products and each one has 5 images.
  })
);

// Cache all videos on the site
registerRoute(
  ({ request }: { request: Request }) => request.destination === "video",
  new StaleWhileRevalidate({
    cacheName: "videos",
    plugins: [new ExpirationPlugin({ maxEntries: 100 })], // Probably we need to adjust this number in the future.
  })
);

// Allow the web app to trigger skipWaiting via registration.waiting.postMessage({ type: 'SKIP_WAITING' })
self.addEventListener("message", (event: ExtendableMessageEvent) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.

/*
 *
 * Start of custom service worker logic to cache the graphql POST requests.
 * Why do we need this?
 * Ans: Browser cache storage doesn't has an ability to persist POST requests as a keys. See https://w3c.github.io/ServiceWorker/#cache-put (point 4).
 * Here is the reference for the solution (we used the second solution): https://medium.com/@jono/cache-graphql-post-requests-with-service-worker-100a822a388a
 */

/*
 *
 * Updated service worker logic to cache both GraphQL POST requests and REST API GET requests.
 *
 */

self.addEventListener("fetch", (event: FetchEvent) => {
  const { request } = event;

  // Handle GraphQL POST requests
  if (request.method === "POST" && isGraphQLRequest(request)) {
    event.respondWith(staleWhileRevalidate(event));
    return;
  }

  // Handle REST API GET requests
  if (request.method === "GET" && isRestApiRequest(request)) {
    event.respondWith(cacheFirstStrategy(event));
    return;
  }
});

const limitCacheSize = async (cacheName: string, maxItems: number) => {
  const cache = await caches.open(cacheName);
  const keys = [...(await cache.keys())]; // copy into a mutable array

  while (keys.length > maxItems) {
    await cache.delete(keys[0]); // delete oldest
    keys.shift(); // now safe to mutate
  }
};

// Helper function to check if the request is a GraphQL request
const isGraphQLRequest = (request: Request): boolean =>
  request.url.includes("/graphql"); // Modify based on your GraphQL API endpoint

// Helper function to check if the request is a REST API request
const isRestApiRequest = (request: Request): boolean =>
  request.url.includes("/wp-json/wc/v3/"); // Modify based on your REST API structure

// IndexedDB setup for GraphQL caching
const store = new Store("Cache-Storage", "Responses");

/**
 * Cache-First Strategy for REST API (GET Requests)
 * Returns the cached response if available, otherwise fetches from network and caches it.
 */
const cacheFirstStrategy = async (event: FetchEvent): Promise<Response> => {
  const cache = await caches.open("rest-api-cache");
  const cachedResponse = await cache.match(event.request);

  if (cachedResponse) {
    return cachedResponse;
  }

  try {
    const networkResponse = await fetch(event.request.clone());
    await cache.put(event.request, networkResponse.clone());

    // âœ… Add this line right after cache.put
    await limitCacheSize("rest-api-cache", 100); // Limit to 100 API responses

    return networkResponse;
  } catch (error) {
    console.error("cacheFirstStrategy error:", error);
    return new Response(null, {
      status: 503,
      statusText: "Service Unavailable",
    });
  }
};

/**
 * Stale-While-Revalidate Strategy for GraphQL (POST Requests)
 * Returns the cached response first if available and updates it in the background.
 */
const staleWhileRevalidate = async (event: FetchEvent): Promise<Response> => {
  let cachedResponse: Response | null = await getCache(event.request.clone());

  try {
    if (cachedResponse) {
      // Fetch in the background to update the cache
      fetch(event.request.clone())
        .then(async (fetchResponse) => {
          const responseClone = fetchResponse.clone();
          await setCache(event.request.clone(), responseClone);
        })
        .catch((error) => {
          console.error("Fetch error:", error);
        });

      return cachedResponse;
    }

    // If no cached response is found, fetch from the network
    const fetchResponse = await fetch(event.request.clone());
    const responseClone = fetchResponse.clone();
    await setCache(event.request.clone(), responseClone);

    return fetchResponse;
  } catch (error) {
    console.error("staleWhileRevalidate error:", error);
    // If an error occurs during the process, return the cached response if available
    // Otherwise, return a generic service unavailable response
    return (
      cachedResponse ||
      new Response(null, { status: 503, statusText: "Service Unavailable" })
    );
  }
};

/**
 * Retrieve GraphQL cached response from IndexedDB
 */
const getCache = async (request: Request): Promise<Response | null> => {
  try {
    const body = await request.clone().json();
    const id = CryptoJS.MD5(body.query).toString();
    const data = await get<{
      response: CachedResponse;
      timestamp: number;
    } | null>(id, store);

    if (!data) return null;

    const isCachedExpired = Date.now() - data.timestamp > 3600 * 1000; // Cache expiration in seconds
    if (isCachedExpired) return null;

    return new Response(JSON.stringify(data.response.body), data.response);
  } catch (err) {
    console.error(err);
    return null;
  }
};

/**
 * Store GraphQL response in IndexedDB
 */
const setCache = async (
  request: Request,
  response: Response
): Promise<void> => {
  try {
    const body = await request.clone().json();
    const id = CryptoJS.MD5(body.query).toString();
    const entry = {
      query: body.query,
      response: await serializeResponse(response),
      timestamp: Date.now(),
    };
    await set(id, entry, store);
  } catch (err) {
    console.error(err);
  }
};

/**
 * Serialize response for GraphQL caching
 */
const serializeResponse = async (
  response: Response
): Promise<CachedResponse> => {
  const serializedHeaders: Record<string, string> = {};
  for (const [key, value] of response.headers.entries()) {
    serializedHeaders[key] = value;
  }

  return {
    headers: serializedHeaders,
    status: response.status,
    statusText: response.statusText,
    body: await response.json(),
  };
};

/**
 * Cached Response Interface
 */
interface CachedResponse {
  headers: Record<string, string>;
  status: number;
  statusText: string;
  body: any;
}

/*
 * End of custom service worker logic to cache the graphql POST requests.
 */
